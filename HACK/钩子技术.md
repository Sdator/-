


>## 钩子
+ 由于程序之间的进程空间都是独立的 需要跨进程 注入dll或创建远程线程 来达成空间统一方可操作
+ 查询 API 内部地址 GetProcAddress



### 原生钩子 R3
+ 微软原生提供的 支持十三种类型的信息钩子
+ SetWindowsHookEx 内置钩子

### API HOOK R3
+ 通过修改 API 地址跳转到另外一个程序来处理 达成钩子过程
+ 常见的2种 API Hook
  + 基于PE文件的导入表(IAT) 函数表
  + 修改前5个字节直接 JMP 的 inline Hook.

### IAT HOOK
  + PE文件里有个导入表， 代表该模块调用了哪些外部API，模块被加载到内存后， PE加载器会修改该表，地址改成外部API重定位后的真实地址， 我们只要直接把里面的地址改成我们新函数的地址， 就可以完成对相应API的Hook。




### SSDT HOOK R0 内核钩子、全局钩子 已经落后
+ 系统服务描述符表
  + R3 API 和 R0 API 的桥梁 R3运行的API会通过查询SSDT获得R0的地址并且运行
  + 这个表就是一个把 ring3 的 Win32 API 和 ring0 的内核 API 联系起来
  + 它还包含着一些其它有用的信息，诸如地址索引的基地址、服务函数个数等
+ 修改 SSDT 表地址会产生全局钩子效果，所有程序的同一个 API 都会被钩住

+ 细节
  + R3层由于权限问题是无法直接修改R0层的SSDT表 但驱动默认是在R0层 所以可通过驱动去实现
+ 应用
  + 已知 TerminateProcess 关闭进程之前需要打开进程 OpenProcess
  + 杀毒软件在任务管理器中无法关闭 是因为进行了 SSDT 钩住了打开进程 OpenProcess，只要判断窗口句柄为自身的程序 返回获取句柄失败


> 参考
> http://tieba.baidu.com/p/2639420374#40042773144l



>## 钩子应用
### 程序多开
+ 软件可以通过创建互斥体(一个api函数)来防止多开 可 hook 住这个地址实现多开
### 封包拦截
+ hook send函数，这样发送封包(调用send函数)之前会先调用自己的函数，就可以获取甚至修改封包内容了




>## 断点
### INT3断点
+ 指令 CC
+ 行为
  + 在 API 入口改写 CC 指令触发异常断点
  + 当被调试进程执行INT3指令导致一个异常时，调试器就会捕捉这个异常从而停在断点处，然后将断点处的指令恢复成原来的指令
+ 功能
  + 支持无数个断点
+ 缺点
  + 由于改写了原有代码来触发异常 程序内部可能有扫描器回检测 API 入口 解决办法就是把断点打在 API程序内部
