## 面向对象思想


## 泛型委托
// 泛型+labm
Func<int,int,int> func1=(a,b)=>{return a+b}

// 泛型委托
Func<int,int,int> func1 = Add
func1(1,3)

int Add(int a,int,b){
    return a+b;
}



## 泛型
一个类实现了没有特化的泛型继承那么这个类也是泛型类
要使用泛型变成之前必须对其特化 也就是类型初始化
IUnique<TId>        特化前
IUnique<ulong>      特化后      类似固定了


interface IUnique<TId>{
    TId ID{get;set;}
}
### 继承泛型接口  没有特化
class 学生类<TId>:IUnique<TId>{
    // 实现接口
    public TId ID { get; set; }
}

### 继承泛型接口  特化后
class 学生类:IUnique<ulong>{
    // 实现接口
    public TId ID { get; set; }
}



商店里卖出多种不同类型的物品每一种都放在自己对应的盒子中出售

类型膨胀
    如果每一个商品都用独立的一个类包装那么当你有一千种不同的东西出售时候那么就需要很多个类
    class 苹果
    class 苹果盒子
    class 书
    class 书盒子


属性、成员膨胀

    解决了类型膨胀的问题
    但引出属性膨胀的问题

    所有物品都能用同一个盒子存放，盒子可以放入各种不同的物品，但当你只需要放入一种类型的物品时，其他属性就没有起到作用反而白白占用了资源，如果某天突然下架了一些商品还得从类中删除对应的属性造成了 封装不改动原则

    好比一个收纳盒如果只放小螺丝那么浪费的空间是非常多

    class 苹果
    class 书
    class 盒子
        苹果
        书

魔术盒子
    问题
        输入容易输出难

    通过单根类型Obj类 可以存放任何东西 由于所有的类都是继承自obj

    class 苹果类
    class 书本类
    class 盒子
        obj(任何东西)

    苹果类 苹果 = new 苹果类(){颜色=“红色”}
    书本类 书本 = new 书本类(){重量=50}
    # 存放时很好放
    盒子 盒子1 = new 盒子(){ obj = 苹果 }
    盒子 盒子2 = new 盒子(){ obj = 书   }

    print(盒子1.obj.颜色)

    # 当盒子1里存放的不是苹果时，会导致属性读取错误
    # 这样拿出来时就很难 ，因为盒子里的东西是无法确认
    # 解决方法有
        1 通过类型强制转换
        2 as关键字
    print((苹果类)盒子1.obj.颜色)

    # 当盒子1中存放的是苹果时才输出颜色
    # 符号 ？ 是表示不确定性
    print((盒子1.obj as 苹果类)?.颜色 )

泛型
    解决以上问题

    class 苹果类
    class 书本类
    class 盒子<T东西>
        pubilc T东西 东西{get;set;}

    使用

    苹果类 苹果 = new 苹果类(){颜色=“红色”}
    书本类 书本 = new 书本类(){重量=50}

    盒子<苹果类> 盒子1 = new 盒子<苹果类>(){东西=苹果}
    盒子<书本类> 盒子2 = new 盒子<书本类>(){东西=书本}